using System.Text;
using Microsoft.CodeAnalysis;

namespace Terminal.Shell.CodeAnalysis;

[Generator(LanguageNames.CSharp)]
public class MenuCommandGenerator : IIncrementalGenerator
{
    static readonly SymbolDisplayFormat fileName = new(typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces);
    static readonly SymbolDisplayFormat fullName = new(
        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
        genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters);

    record ResourceMetadata(string Name, string Namespace, string ResourceName);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var attribute = context.CompilationProvider
            .Select((x, c) => x.GetTypeByMetadataName("Terminal.Shell.MenuCommandAttribute"));

        var methods = context.CompilationProvider.SelectMany((x, c) =>
        {
            var visitor = new MethodsVisitor(s =>
                // Must be declared in the current assembly
                s.ContainingAssembly.Equals(x.Assembly, SymbolEqualityComparer.Default) &&
                // And be accessible within the current assembly (i.e. not a private nested type)
                x.IsSymbolAccessibleWithin(s, x.Assembly), c);

            x.GlobalNamespace.Accept(visitor);

            return visitor.MethodSymbols;
        });

        static bool IsMenuAttribute(AttributeData data, INamedTypeSymbol attribute) =>
            data.AttributeClass?.Equals(attribute, SymbolEqualityComparer.Default) ?? false;

        var methodMenus = methods
            .Combine(attribute)
            .Where(x => x.Right != null)
            .Where(x => x.Left.GetAttributes().Any(a => IsMenuAttribute(a, x.Right!)))
            .Select((x, _) => new
            {
                Method = x.Left,
                MenuIds = x.Left.GetAttributes().Where(a => IsMenuAttribute(a, x.Right!)).ToList()
            });

        context.RegisterImplementationSourceOutput(methodMenus,
            (ctx, data) =>
            {
                var ns = data.Method.ContainingNamespace.ToDisplayString(fullName);
                var nsdot = ns + ".";

                string ToTypeName(ITypeSymbol type)
                {
                    var display = type.ToDisplayString(fullName);
                    if (display.StartsWith(nsdot))
                        return display[nsdot!.Length..];

                    return display;
                }

                var type = $"{data.Method.ContainingType.Name}_{data.Method.Name}MenuCommand";
                var parameters = data.Method.Parameters.Select(p => new { p.Name, p.Type }).ToList();
                if (!data.Method.IsStatic)
                    parameters.Insert(0, new { Name = "_instance", Type = (ITypeSymbol)data.Method.ContainingType });

                var builder = new StringBuilder().AppendLine(
                    $"""
                    // <auto-generated />
                    using System.Composition;

                    namespace {ns};
                    
                    [Export(typeof(IMenuCommand))]
                    """);

                foreach (var attr in data.MenuIds)
                {
                    builder.AppendLine(
                        $"""
                        [ExportMetadata("Name", "{attr.ConstructorArguments[0].Value}")]
                        """);
                }

                builder.AppendLine(
                    $$"""
                    partial class {{type}} : IMenuCommand
                    {
                    """);

                foreach (var parameter in parameters
                    // Skip the async cancellation token
                    .Where(x => x.Type.Name != nameof(CancellationToken)))
                {
                    builder.AppendLine($"    readonly {ToTypeName(parameter.Type)} {parameter.Name};");
                }

                // Don't generate ctor at all unless we have something to import.
                if (!data.Method.IsStatic || parameters.Where(x => x.Type.Name != nameof(CancellationToken)).Any())
                {

                    builder.AppendLine(
                        $$"""
                    
                            [ImportingConstructor]
                            public {{type}}({{string.Join(", ", parameters
                                .Where(x => x.Type.Name != nameof(CancellationToken))
                                .Select(x => $"{ToTypeName(x.Type)} {x.Name}"))}})
                            {
                        """);

                    foreach (var parameter in parameters
                        // Skip the async cancellation token
                        .Where(x => x.Type.Name != nameof(CancellationToken)))
                    {
                        builder.AppendLine($"        this.{parameter.Name} = {parameter.Name};");
                    }

                    builder.AppendLine(
                        $$"""
                            }
                            
                        """);
                }

                builder.AppendLine(
                    $$"""
                        public Task ExecuteAsync(CancellationToken cancellation = default)
                        {                    
                    """);

                var target = data.Method.IsStatic ? data.Method.ContainingType.Name : "_instance";
                var isAsync = data.Method.ReturnType.Name == nameof(Task);
                if (!data.Method.IsStatic)
                    // For invocation, we don't need the first ("this") param
                    parameters.RemoveAt(0);

                if (isAsync)
                {
                    builder.AppendLine(
                        $"""
                                 return {target}.{data.Method.Name}({string.Join(", ", parameters.Select(x => x.Name))});
                         """);
                }
                else
                {
                    builder.AppendLine(
                        $"""
                                 {target}.{data.Method.Name}({string.Join(", ", parameters.Select(x => x.Name))});
                                 return Task.CompletedTask;
                        """);
                }

                builder.AppendLine(
                    $$"""
                        }
                    }
                    """);

                ctx.AddSource($"{data.Method.ContainingType.ToDisplayString(fileName)}.{data.Method.Name}.g", builder.ToString());
            });
    }

    class MethodsVisitor : SymbolVisitor
    {
        Func<IMethodSymbol, bool> shouldInclude;
        CancellationToken cancellation;
        HashSet<IMethodSymbol> methods = new(SymbolEqualityComparer.Default);

        public MethodsVisitor(Func<IMethodSymbol, bool> shouldInclude, CancellationToken cancellation)
        {
            this.shouldInclude = shouldInclude;
            this.cancellation = cancellation;
        }

        public HashSet<IMethodSymbol> MethodSymbols => methods;

        public override void VisitAssembly(IAssemblySymbol symbol)
        {
            cancellation.ThrowIfCancellationRequested();
            symbol.GlobalNamespace.Accept(this);
        }

        public override void VisitNamespace(INamespaceSymbol symbol)
        {
            foreach (var namespaceOrType in symbol.GetMembers())
            {
                cancellation.ThrowIfCancellationRequested();
                namespaceOrType.Accept(this);
            }
        }

        public override void VisitNamedType(INamedTypeSymbol type)
        {
            cancellation.ThrowIfCancellationRequested();

            foreach (var member in type.GetMembers())
                member.Accept(this);

            foreach (var nestedType in type.GetTypeMembers())
                nestedType.Accept(this);
        }

        public override void VisitMethod(IMethodSymbol symbol)
        {
            if (shouldInclude(symbol))
                methods.Add(symbol);
        }
    }

    class TypesVisitor : SymbolVisitor
    {
        Func<ISymbol, bool> shouldInclude;
        CancellationToken cancellation;
        HashSet<INamedTypeSymbol> types = new(SymbolEqualityComparer.Default);

        public TypesVisitor(Func<ISymbol, bool> shouldInclude, CancellationToken cancellation)
        {
            this.shouldInclude = shouldInclude;
            this.cancellation = cancellation;
        }

        public HashSet<INamedTypeSymbol> TypeSymbols => types;

        public override void VisitAssembly(IAssemblySymbol symbol)
        {
            cancellation.ThrowIfCancellationRequested();
            symbol.GlobalNamespace.Accept(this);
        }

        public override void VisitNamespace(INamespaceSymbol symbol)
        {
            foreach (var namespaceOrType in symbol.GetMembers())
            {
                cancellation.ThrowIfCancellationRequested();
                namespaceOrType.Accept(this);
            }
        }

        public override void VisitNamedType(INamedTypeSymbol type)
        {
            cancellation.ThrowIfCancellationRequested();

            if (!shouldInclude(type) || !types.Add(type))
                return;

            var nestedTypes = type.GetTypeMembers();
            if (nestedTypes.IsDefaultOrEmpty)
                return;

            foreach (var nestedType in nestedTypes)
            {
                cancellation.ThrowIfCancellationRequested();
                nestedType.Accept(this);
            }
        }
    }
}
