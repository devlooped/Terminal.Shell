using System.Security.Cryptography;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Scriban;

namespace Terminal.Shell.CodeAnalysis;

[Generator(LanguageNames.CSharp)]
public class ContextExpressionGenerator : IIncrementalGenerator
{
    static readonly HashAlgorithm hasher = MD5.Create();
    static readonly Template template;

    static ContextExpressionGenerator()
    {
        using var resource = typeof(ContextExpressionGenerator).Assembly.GetManifestResourceStream("Terminal.Shell.ContextExpression.sbntxt");
        using var reader = new StreamReader(resource!);
        template = Template.Parse(reader.ReadToEnd());
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var syntax = context.SyntaxProvider.CreateSyntaxProvider(
            (node, _) => node.IsKind(SyntaxKind.AttributeArgument) || node.IsKind(SyntaxKind.Argument),
            (ctx, _) => ctx)
            .Combine(context.CompilationProvider);

        // NOTE: generated types must be public, even if MEF does not require that.
        // This is a restriction of the CSharpScript class that is used to compile
        // the expression which uses the context type. Not even using the (poorly 
        // documented) IgnoreAccessChecksTo (see https://www.strathweb.com/2018/10/no-internalvisibleto-no-problem-bypassing-c-visibility-rules-with-roslyn/)
        // can workaround this limitation :(.
        context.RegisterImplementationSourceOutput(context.CompilationProvider,
            (ctx, _) => ctx.AddSource("ContextExpression.Generated.g",
                    """
                    //------------------------------------------------------------------------------
                    // <auto-generated>
                    //     This code was generated by a tool.
                    //
                    //     Changes to this file may cause incorrect behavior and will be lost if
                    //     the code is regenerated.
                    // </auto-generated>
                    //------------------------------------------------------------------------------
                    using System.ComponentModel;
                    using System.Composition;

                    namespace Terminal.Shell;

                    [EditorBrowsable(EditorBrowsableState.Never)]
                    public partial class ContextExpressions
                    {
                        [Shared]
                        public partial class Generated
                        {
                        }
                    }
                    """));

        bool IsContextExpressionOperation(INamedTypeSymbol attr, IOperation? operation) => operation switch
        {
            // Attribute ctor (named/positional) and regular method calls
            IArgumentOperation arg when
                arg.Parameter is IParameterSymbol param &&
                param.GetAttributes().Any(x => attr.Equals(x.AttributeClass, SymbolEqualityComparer.Default)) => true,
            // Attribute named prop
            ISimpleAssignmentOperation assign when
                assign.Target is IPropertyReferenceOperation prop &&
                prop.Property.GetAttributes().Any(x => attr.Equals(x.AttributeClass, SymbolEqualityComparer.Default)) => true,
            _ => false
        };

        string? GetContextExpression(INamedTypeSymbol attr, IOperation operation) => operation switch
        {
            // Attribute named prop
            ISimpleAssignmentOperation assign when
                assign.Target is IPropertyReferenceOperation prop &&
                assign.Value.ConstantValue.HasValue &&
                assign.Value.ConstantValue.Value is string value => value,
            // Attribute ctor (named/positional) and regular method calls
            IArgumentOperation arg when
                arg.Value.ConstantValue.HasValue &&
                arg.Value.ConstantValue.Value is string value => value,
            IArgumentOperation arg when
                arg.Value is ILocalReferenceOperation local &&
                local.Local.HasConstantValue &&
                local.Local.ConstantValue is string value => value,
            IArgumentOperation arg when
                // argument points to a local reference where the variable 
                // is initialized to a constant value
                arg.Value is ILocalReferenceOperation local &&
                local.Local.DeclaringSyntaxReferences.FirstOrDefault() is SyntaxReference sr &&
                operation.SemanticModel?.GetOperation(sr.GetSyntax()) is IVariableDeclaratorOperation decl &&
                decl.Initializer?.Value.ConstantValue.HasValue == true &&
                decl.Initializer.Value.ConstantValue.Value is string value => value,
            IArgumentOperation arg when
                // argument points to a field reference where the field
                // is initialized to a constant value
                arg.Value is IFieldReferenceOperation field &&
                field.Field.DeclaringSyntaxReferences.FirstOrDefault() is SyntaxReference sr &&
                sr.GetSyntax() is VariableDeclaratorSyntax decl &&
                decl.Initializer is not null &&
                operation.SemanticModel?.GetConstantValue(decl.Initializer.Value) is Optional<object> optional &&
                optional.HasValue && optional.Value is string value => value,
            IArgumentOperation arg when
                // argument points to a parameter that itself has been annotated as a context expression, 
                // so we can safely skip it, use an empty string as a signal to skip
                arg.Value is IParameterReferenceOperation parameter &&
                parameter.Parameter.GetAttributes().Any(x => attr.Equals(x.AttributeClass, SymbolEqualityComparer.Default)) => "",
            IArgumentOperation arg when
                // argument points to a parameter that itself has been annotated as a context expression, 
                // so we can safely skip it, use an empty string as a signal to skip
                arg.Value is IPropertyReferenceOperation prop &&
                prop.Property.GetAttributes().Any(x => attr.Equals(x.AttributeClass, SymbolEqualityComparer.Default)) => "",
            _ => default
        };

        var expressions = syntax
            .Where(x =>
                x.Right.GetTypeByMetadataName("Terminal.Shell.ContextExpressionAttribute") is INamedTypeSymbol expr &&
                IsContextExpressionOperation(expr, x.Left.SemanticModel.GetOperation(x.Left.Node)))
            .Select((x, c) =>
            {
                var attr = (INamedTypeSymbol)x.Right.GetTypeByMetadataName("Terminal.Shell.ContextExpressionAttribute")!;
                var expression = GetContextExpression(attr, x.Left.SemanticModel.GetOperation(x.Left.Node)!);
                var hash = new string(hasher.ComputeHash(Encoding.ASCII.GetBytes(expression ?? ""))
                    .SelectMany(x => x.ToString("x2"))
                    .Where(SyntaxFacts.IsIdentifierPartCharacter)
                    .ToArray());

                return new { Expression = expression, Hash = hash, Location = x.Left.Node.GetLocation() };
            });

        context.RegisterImplementationSourceOutput(
            expressions.Collect(),
            (ctx, data) =>
            {
                foreach (var group in data.GroupBy(x => x.Hash))
                {
                    var expression = group.First().Expression;
                    if (expression == null)
                    {
                        // Report expressions we couldn't resolve to constant values as warnings
                        foreach (var unresolved in group)
                        {
                            ctx.ReportDiagnostic(Diagnostic.Create(
                                Diagnostics.ContextExpressionMustBeConstant,
                                unresolved.Location));
                        }
                        continue;
                    }
                    else if (expression.Trim().Length == 0)
                    {
                        // No need for evaluation context for empty expressions
                        continue;
                    }

                    var script = CSharpScript.Create(expression);
                    var compilation = script.GetCompilation();
                    var diagnostics = compilation.GetParseDiagnostics(ctx.CancellationToken);
                    if (diagnostics.Any())
                    {
                        // report invalid expression context diagnostic
                        ctx.ReportDiagnostic(Diagnostic.Create(
                            Diagnostics.InvalidContextExpression,
                            group.First().Location,
                            group.Skip(1).Select(x => x.Location),
                            expression));

                        continue;
                    }

                    // We need to parse the expression, then emit with each identifier found
                    var parsed = CSharpSyntaxTree.ParseText(expression, cancellationToken: ctx.CancellationToken);
                    var identifiers = parsed.GetRoot(ctx.CancellationToken).DescendantNodes()
                        .OfType<IdentifierNameSyntax>()
                        .Select(x => x.Identifier.Text);

                    var output = template.Render(new
                    {
                        TypeName = "_" + group.Key,
                        Expression = expression,
                        Properties = identifiers
                    }, member => member.Name);

                    ctx.AddSource($"_{group.Key}.g", output);
                }
            });
    }
}
