using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Scriban;

namespace Terminal.Shell.CodeAnalysis;

[Generator(LanguageNames.CSharp)]
public class ContextExtensionsGenerator : IIncrementalGenerator
{
    static readonly Template pushTemplate;
    static readonly Template getTemplate;

    public record NameType(string Name, string Type);

    static ContextExtensionsGenerator()
    {
        using var pushResource = Assembly.GetExecutingAssembly().GetManifestResourceStream("Terminal.Shell.ContextPush.sbntxt");
        using var pushReader = new StreamReader(pushResource!);
        pushTemplate = Template.Parse(pushReader.ReadToEnd());

        using var getResource = Assembly.GetExecutingAssembly().GetManifestResourceStream("Terminal.Shell.ContextTryGet.sbntxt");
        using var getReader = new StreamReader(getResource!);
        getTemplate = Template.Parse(getReader.ReadToEnd());
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource("ContextExtensions.g",
            """
            //------------------------------------------------------------------------------
            // <auto-generated>
            //     This code was generated by a tool.
            //
            //     Changes to this file may cause incorrect behavior and will be lost if
            //     the code is regenerated.
            // </auto-generated>
            //------------------------------------------------------------------------------
            #nullable enable
            #if !TSH_NoContextExtensions

            using System;
            using System.Diagnostics.CodeAnalysis;

            namespace Terminal.Shell;

            static partial class ContextExtensions
            {
                public static IDisposable Push<T>(this IContext context, T value) => Push(context, typeof(T).Name, (dynamic)value!);
                public static IDisposable Push(this IContext context, string name, object value) => throw new NotSupportedException();
                public static bool TryGet<T>(this IContext context, [MaybeNullWhen(false)] out T value) => TryGet<T>(context, typeof(T).Name, out value);
                public static partial bool TryGet<T>(this IContext context, string name, [MaybeNullWhen(false)] out T value);
            }

            #endif
            """));

        var syntax = context.SyntaxProvider.CreateSyntaxProvider(
            (node, _) => node.IsKind(SyntaxKind.InvocationExpression),
            (ctx, _) =>
            {
                var invocation = (InvocationExpressionSyntax)ctx.Node;
                var method = ctx.SemanticModel.GetSymbolInfo(ctx.Node).Symbol as IMethodSymbol;
                if (method is null &&
                    invocation.Expression is MemberAccessExpressionSyntax member &&
                    member.Name.Identifier.ToString() == "Push")
                {
                    // Narrow down to the intended overload we want.
                    method = ctx.SemanticModel.GetSymbolInfo(ctx.Node).CandidateSymbols.OfType<IMethodSymbol>()
                        // We allow a name-less push where we infer it from the type name
                        .FirstOrDefault(x => x.IsExtensionMethod && x.Parameters.Length >= 1 && x.ContainingType?.Name == "ContextExtensions");
                }

                return new
                {
                    Invocation = (InvocationExpressionSyntax)ctx.Node,
                    Method = method,
                    ctx.SemanticModel,
                };
            })
            .Where(x => x.Method != null && x.Method.IsExtensionMethod && x.Method.Parameters.Length >= 1 && x.Method.ContainingType?.Name == "ContextExtensions")
            .Where(x => x.Method!.Name == "Push" || x.Method!.Name == "TryGet")
            .Combine(context.CompilationProvider);

        var invocations = syntax
            .Where(x =>
                x.Right.GetTypeByMetadataName("Terminal.Shell.ContextExtensions") is INamedTypeSymbol extensions &&
                x.Right.GetTypeByMetadataName("Terminal.Shell.IContext") is INamedTypeSymbol context &&
                // Further assurances with direct checks against compilation types for extra safety
                x.Left.Method?.ReducedFrom?.Parameters[0].Type.Equals(context, SymbolEqualityComparer.Default) == true &&
                extensions.Equals(x.Left.Method?.ContainingType, SymbolEqualityComparer.Default))
            .Select((x, c) =>
            {
                // Get<T> vs Push()
                var data = x.Left.Method!.IsGenericMethod ? x.Left.Method.TypeArguments[0] :
                    // Type equals whatever instance type we find as the last argument.
                    x.Left.SemanticModel.GetSymbolInfo(x.Left.Invocation.ArgumentList.Arguments.Last().Expression).Symbol! switch
                    {
                        IMethodSymbol m when m.MethodKind == MethodKind.Constructor => m.ReceiverType,
                        IMethodSymbol m => m.ReturnType,
                        IPropertySymbol p => p.Type,
                        IFieldSymbol f => f.Type,
                        ILocalSymbol l => l.Type,
                        _ => null
                    };

                return new
                {
                    Compilation = x.Right,
                    DataType = data?.SpecialType == SpecialType.System_Void ? null : data,
                    x.Left.Invocation,
                    x.Left.Method
                };
            })
            .Where(x => x.DataType != null);

        context.RegisterImplementationSourceOutput(
            invocations.Where(x => x.Method.Name == "Push").Collect(),
            (ctx, data) =>
            {
                foreach (var group in data.GroupBy(x => x.DataType, SymbolEqualityComparer.Default))
                {
                    if (group.Key is not INamedTypeSymbol type ||
                        group.FirstOrDefault()?.Compilation is not Compilation compilation)
                        continue;

                    var output = pushTemplate.Render(new
                    {
                        Type = type.ToFullName(compilation),
                        Properties = type
                            .GetMembers()
                            .OfType<IPropertySymbol>()
                            .Where(x => !x.IsImplicitlyDeclared && x.GetMethod != null)
                            .Select(x => x.Name)
                    }, member => member.Name);

                    ctx.AddSource($"ContextExtensions.Push.{type.ToDisplayString(SourceAction.FileNameFormat)}.g", output);
                }
            });

        context.RegisterImplementationSourceOutput(
            invocations.Where(x => x.Method.Name == "TryGet").Collect(),
            (ctx, data) =>
            {
                if (data.FirstOrDefault()?.Compilation is not Compilation compilation)
                {
                    // Emit at least empty Get<T> implementation.
                    ctx.AddSource($"ContextExtensions.TryGet.g",
                        """
                        //------------------------------------------------------------------------------
                        // <auto-generated>
                        //     This code was generated by a tool.
                        //
                        //     Changes to this file may cause incorrect behavior and will be lost if
                        //     the code is regenerated.
                        // </auto-generated>
                        //------------------------------------------------------------------------------
                        #nullable enable
                        #if !TSH_NoContextExtensions
                        
                        namespace Terminal.Shell;

                        static partial class ContextExtensions
                        {
                            public static partial bool TryGet<T>(this IContext context, string name, out T value)
                            {
                                value = default!;
                                return false;
                            }
                        }

                        #endif
                        """);

                    return;
                }

                var get = getTemplate.Render(new
                {
                    Types = data.GroupBy(x => x.DataType, SymbolEqualityComparer.Default)
                        .Select(g =>
                        {
                            var type = (INamedTypeSymbol)g.Key!;
                            var ctor = type.Constructors.OrderByDescending(x => x.Parameters.Length).FirstOrDefault();
                            var args = ctor?.Parameters.Select(x => new NameType(x.Name, x.Type.ToFullName(compilation)));
                            var recordProps = type.IsRecord ? new HashSet<string>(ctor?.Parameters.Select(x => x.Name)) : new HashSet<string>();
                            var props = type.GetMembers().OfType<IPropertySymbol>()
                                // Skip record auto-properties
                                .Where(x => !x.IsImplicitlyDeclared && !x.IsReadOnly && !recordProps.Contains(x.Name))
                                .Select(x => new NameType(x.Name, x.Type.ToFullName(compilation)));

                            return new
                            {
                                Type = g.Key!.ToFullName(compilation),
                                Arguments = args,
                                Properties = props,
                                Values = args.Concat(props).Distinct(ByNameEqualityComparer.Default)
                            };
                        })
                }, member => member.Name);

                ctx.AddSource($"ContextExtensions.TryGet.g", get);
            });
    }

    class ByNameEqualityComparer : IEqualityComparer<NameType>
    {
        public static IEqualityComparer<NameType> Default { get; } = new ByNameEqualityComparer();

        ByNameEqualityComparer() { }

        public bool Equals(NameType x, NameType y) => x.Name == y.Name;
        public int GetHashCode(NameType obj) => obj.Name.GetHashCode();
    }
}
