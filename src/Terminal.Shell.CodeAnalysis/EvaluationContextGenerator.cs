using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Scriban;
using static Terminal.Shell.EvaluationContextExtensions;

namespace Terminal.Shell;

[Generator(LanguageNames.CSharp)]
public class EvaluationContextGenerator : IIncrementalGenerator
{
    static readonly HashAlgorithm hasher = MD5.Create();
    static readonly Template template;

    static EvaluationContextGenerator()
    {
        using var resource = Assembly.GetExecutingAssembly().GetManifestResourceStream("Terminal.Shell.EvaluationContext.sbntxt");
        using var reader = new StreamReader(resource!);
        template = Template.Parse(reader.ReadToEnd());
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var syntax = context.SyntaxProvider.CreateSyntaxProvider(
            (node, _) => node.IsKind(SyntaxKind.AttributeArgument),
            (ctx, _) => ctx)
            .Combine(context.CompilationProvider);

        // NOTE: generated types must be public, even if MEF does not require that.
        // This is a restriction of the CSharpScript class that is used to compile
        // the expression which uses the context type. Not even using the (poorly 
        // documented) IgnoreAccessChecksTo (see https://www.strathweb.com/2018/10/no-internalvisibleto-no-problem-bypassing-c-visibility-rules-with-roslyn/)
        // can workaround this limitation :(.
        context.RegisterImplementationSourceOutput(context.CompilationProvider,
            (ctx, _) =>
            {
                ctx.AddSource("EvaluationContext.Generated.g",
                    """
                    //------------------------------------------------------------------------------
                    // <auto-generated>
                    //     This code was generated by a tool.
                    //
                    //     Changes to this file may cause incorrect behavior and will be lost if
                    //     the code is regenerated.
                    // </auto-generated>
                    //------------------------------------------------------------------------------
                    using System.ComponentModel;
                    using System.Composition;

                    namespace Terminal.Shell;

                    [EditorBrowsable(EditorBrowsableState.Never)]
                    public partial class ExpressionContext
                    {
                        [Shared]
                        public partial class Generated
                        {
                        }
                    }
                    """);
            });

        var filtered = syntax
            .Where(x =>
                x.Left.Node is AttributeArgumentSyntax arg &&
                x.Left.Node.Parent?.Parent is AttributeSyntax attr &&
                x.Right.GetTypeByMetadataName("Terminal.Shell.ContextExpressionAttribute") is INamedTypeSymbol expr &&
                x.Left.SemanticModel.GetSymbolInfo(attr).Symbol is IMethodSymbol ctor &&
                x.Left.SemanticModel.GetConstantValue(arg.Expression) is { HasValue: true } constant && 
                constant.Value is string &&
                (IsNamedArgContextExpression(expr, ctor, arg, attr) ||
                 IsNamedPropContextExpression(expr, ctor, arg, attr) ||
                 IsIndexArgContextExpresion(expr, ctor, arg, attr)))
            .Select((x, c) =>
            {
                var arg = (AttributeArgumentSyntax)x.Left.Node;
                var expression = (string)x.Left.SemanticModel.GetConstantValue(arg.Expression).Value!;
                var hash = new string(hasher.ComputeHash(Encoding.ASCII.GetBytes(expression))
                    .SelectMany(x => x.ToString("x2"))
                    .Where(SyntaxFacts.IsIdentifierPartCharacter)
                    .ToArray());

                return new { Expression = expression, Hash = hash, Location = arg.GetLocation() };
            });

        context.RegisterImplementationSourceOutput(filtered.Collect(),
            (ctx, data) =>
            {
                foreach (var group in data.GroupBy(x => x.Hash))
                {
                    var expression = group.First().Expression;
                    var script = CSharpScript.Create(expression);
                    var compilation = script.GetCompilation();
                    var diagnostics = compilation.GetParseDiagnostics(ctx.CancellationToken);
                    if (diagnostics.Any())
                    {
                        // report invalid expression context diagnostic
                        ctx.ReportDiagnostic(Diagnostic.Create(
                            Diagnostics.InvalidContextExpression,
                            group.First().Location,
                            group.Skip(1).Select(x => x.Location),
                            expression));

                        continue;
                    }

                    // We need to parse the expression, then emit with each identifier found
                    var parsed = CSharpSyntaxTree.ParseText(expression, cancellationToken: ctx.CancellationToken);
                    var identifiers = parsed.GetRoot(ctx.CancellationToken).DescendantNodes()
                        .OfType<IdentifierNameSyntax>()
                        .Select(x => x.Identifier.Text);

                    var output = template.Render(new
                    {
                        TypeName = "_" + group.Key,
                        Expression = expression,
                        Properties = identifiers
                    }, member => member.Name);

                    ctx.AddSource($"_{group.Key}.g", output);
                }
            });
    }
}
